# 백준 11401 이항계수의 범위가 큰 값을 -> 서로 서로수이거나 배수가 아닐 경우 페르마의 소정리 를 통해 
# 분할정복을 이용한 거듭제곱과 모듈러 연산을 이용해 크기가 큰 숫자도 빠르게 값을 구하게 만듦
```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
using namespace std;

//분할정복을 이용한 거듭제곱 알고리즘
int n, k;
long long mod = 1000000007;
long long n1 = 1, n2 = 1;

//값을 분할하여 거듭제곱을 모듈러 연산하여 범위가 큰 계산 시간을 줄인다.
long long pow(long long n, long long e) {
    // 만약 값이 0 이면 값은 1로 나뉜다.
    if (e == 0) return 1;
    //재귀함수 사용 값을 모듈러 연산하여 나눔
    long long tmp = pow(n, e / 2) % mod;
    tmp = tmp * tmp % mod;
    //값이 짝수 이상일 경우
    if (e % 2 == 0) {
        return tmp % mod;
    }
    //값이 홀수 이사일 겨우
    else {
        return n * tmp % mod;
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> k;

    //n1 = (n-k)!*k!; 
    for (int i = n - k + 1; i <= n; i++) {
        n1 = n1 * i % mod;
    }
    //n2 = n!;
    for (int i = 1; i <= k; i++) {
        n2 = n2 * i % mod;
    }
    cout << n1 * pow(n2, mod - 2) % mod;
}
```
